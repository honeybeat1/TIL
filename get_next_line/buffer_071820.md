## buffer
printf, scanf, fputc, fgetc.. 표준 입출력 함수를 통해서 데이터를 입출력 하는 경우

- 운영체제가 제공하는 **`메모리 버퍼`**를 중간에 거치게 됨

    → 데이터를 임시로 저장하는 메모리 공간

- 키보드를 통해 입력되는 데이터는
    - 입력 스트림에서 → 엔터 키가 눌리면
        - 입력 버퍼에 저장된 다음 (버퍼링 된 다음)
            - 프로그램(`fgets`, `fgetc`..) 에서 읽혀짐
            - 엔터키가 안 눌리면 아무리 입력해도 프로그램이 못 읽는 것~ 버퍼에 저장이 안되니깐~

버퍼링을 하는 이유?

- 데이터 전송의 효율성
- 키보드가 눌릴 때마다 눌린 문자의 정보를 목적지로 바로 이동시키는 것보다 중간에 메모리 버퍼를 둬서 데이터를 한 데 묶어서 이동시키는 것이 보다 효율적이고 빠르다

#### `fflush` 함수

- 출력 버퍼를 비운다
- 출력 버퍼에 저장된 데이터가 버퍼를 떠나서 목적지로 이동됨 == 출력됨

```c
#include <stdio.h>
int fflush(FILE * stream);
//함수 호출 성공시 0, 실패시 EOF 반환
```

- 인자로 전달된 스트림의 버퍼를 비운다
- 입력 버퍼를 비우는 것 == 데이터 소멸
    - `fflush(stdin)`은 윈도우 계열 컴파일러의 경우 입력 버퍼의 데이터를 소멸시키지만, 그 이외의 컴파일러들은 전혀 다른 결과를 보인다. → 맥OS X에서는 잘 작동한다
    - 다음 코드는 입력 버퍼를 비우는 역할을 수행한다.

        ```c
        void ClearLineFromReadBuffer(void)
        {
        	while(getchar() != '\n');
        }//\n을 만날때까지 계속 읽어들이는 함수. 버퍼에 남아있는건 읽혀지면 없어진다. (출력되지 않더라도)
        ```

- 출처 - 윤성우의 열혈 C 프로그래밍

### 비슷한 함수 `fgets`

```c
#include <stdio.h>

int main(void)
{
	char str[4];
	int i;

	for(i=0; i < 3; i++)
	{
		fgets(str, sizeof(str), stdin);
		printf("%d \n", str);
	}
	return (0);
} 
```

 `1234567890` 을 입력했을 경우, 출력 결과는 버퍼 (`str`)의 크기에 따라 

```c
123
456
789
```

- 3번이 찍힌다. fgets의 stdin이 호출될 때마다 입력하라고 되는 게 아니라 처음 입력했던 값의 남은 값이 찍히는 이유는 입력 스트림에 `1234567890`이 남아있기 때문이다. 더 정확히는 입력 스트림 > 엔터 > 입력 버퍼에 값이 남아있기 때문이다. `fgets`는 `\n`을 만날 때까지 문자열을 읽어 들이기 때문에, 호출 되도 그 전 버퍼에 남아있는 값을 계속 읽어 들인다.
- `fgets`함수는 `\n`을 만날 때까지 문자열을 읽어 들인다. 그런데 `\n`을 제외시키거나 버리지 않고 문자열의 일부로 받아들인다.  엔터를 쳐서 입력했을 때의 `\n`도 문자로 받아들이기 때문에, 만일 버퍼 사이즈보다 작은 값을 입력했을 경우 개행이 두 번 이뤄질 것이다.
- 참고로 `char *str` 으로 선언했을 경우, `sizeof(str)`이 문자열 자료형 크기를 읽어 `8`이 담긴다. 이걸 몰랐었다.. 그래서 8만큼의 버퍼가 담긴당..

 `get_next_line` 도 `\n`을 만날 때까지 문자열을 읽어 들인다.  (one line의 기준)
