## 스트림과 데이터의 이동

콘솔 입출력을 위한 '입력 스트림'과 '출력 스트림'은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다. 기본적으로 제공되는 '표준 스트림'이다.

(스트림 - 한 방향으로 흐르는 데이터의 흐름)

- stdin - 표준 입력 스트림 - 키보드 대상으로 입력
- stdout - 표준 출력 스트림 - 모니터 대상으로 출력
- stderr - 표준 에러 스트림 - 모니터 대상으로 출력

`#include <stdio.h>` 선제시

## 문자 단위 함수

### 출력

→ 함수 호출 성공 시 쓰여진 문자 정보가, 실패시 EOF 반환

- `int putchar(int c);`
    - 표준 출력 스트림으로 전송
- `int fputc(int c, FILE * stream);`
    - 문자를 전송할 스트림을 지정 (파일 대상 데이터 전송 가능)

### 입력

→ 함수 호출 실패 혹은 파일의 끝에 도달 (읽을 내용이 없다면) EOF 반환

- `int getchar(void);`
- `int fgetc(FILE * stream);`

## 문자열 단위 함수

`scanf`와 달리 공백 입력도 가능

### 출력

→ 성공시 음수가 아닌 값을, 실패 시 EOF 반환

- `int puts(const char *s);`

    → 문자열 출력 후 자동으로 \n **개행**이 출력됨 

- `int fputs(const char *s, FILE * stream);`

    → 자동 개행 x

### 입력

→ 파일의 끝에 도달하거나 함수 호출 실패시 NULL 포인터 반환

- `char *gets(const char *s);`

    → 표준 입력 스트림으로 부터 입력 받음

    → 미리 할당해 놓은 메모리 공간을 넘어서는 길이의 문자열이 입력되면 오류

- `char *fgets(const char *s, int n, FILE * stream);`

    → int n에 `sizeof(str)` 을 대입하면?

    → null 문자 (\n)의 저장을 위해 하나 작은 길이의 문자열이 저장됨 

## 반환형이 int이고, int형 변수에 문자를 담는 이유는?

### `EOF`

- End of File
- 파일의 끝을 표현하기 위해서 정의해 놓은 상수 (`-1`)
- 더 이상 읽을 내용이 없다
- 키보드를 대상으로 하는 `fgetc` 와 `putchar` 함수는
    - `ctrl + Z` (취-소) 입력으로 EOF를 반환할 수 있다. (리눅스에서는 ctrl + D)
    - 또는 함수 호출의 실패
    - (프로그램 종료)

### 그래서 `EOF`는 `-1`로 정의된 상수이기 때문에

- char를 unsigned char로 처리하는 컴파일러도 존재한다.
- 따라서 EOF가 양의 정수로 형 변환이 되는 오류가 발생할 수도 있다.
- 그래서 어떤 경우에서도 `-1`을 인식할 수 있는 `int`형으로 반환형을 정의해 놓은 것

##### 문자 단위의 입출력 함수의 존재 이유?

→ `printf`, `scanf` 는 **서식 지정**을 통해 새로운 입출력의 형태를 구성하는 함수

→ 화려한 기능을 제공하는 만큼 사용하는 메모리 공간도 크고, 해야 할 연산의 양도 많아서 상대적으로 속도가 느림
